{"version":3,"sources":["../../src/index.ts","../../../../src/subproviders/subprovider.ts","../../../src/types.ts","../../../../src/subproviders/base_wallet_subprovider.ts","../../../../src/utils/wallet_utils.ts","../../../../src/subproviders/ledger.ts","../../../../src/subproviders/rpc_subprovider.ts","../../../../src/subproviders/private_key_wallet.ts","../../../src/index.ts","../../../../src/utils/subprovider_utils.ts","../../../../src/subproviders/empty_wallet_subprovider.ts","../../../../src/subproviders/fake_gas_estimate_subprovider.ts","../../../../src/subproviders/signer.ts","../../../../src/subproviders/redundant_subprovider.ts","../../../../src/subproviders/ganache.ts","../../../../src/subproviders/nonce_tracker.ts","../../../../src/subproviders/mnemonic_wallet.ts","../../../../src/subproviders/metamask_subprovider.ts","../../../../src/subproviders/trezor.ts","../node_modules/web3-provider-engine/subproviders/cache.js","../node_modules/clone/clone.js","../node_modules/web3-provider-engine/subproviders/subprovider.js"],"names":["AbstractConnector","supportedChainIds","emitUpdate","ConnectorEvent","emitError","emitDeactivate","derivedKeys","_","payload","inherits","require","ethUtil","BN","clone","cacheUtils","Stoplight","Subprovider","BlockCacheProvider","opts","self","this","_ready","strategies","perma","ConditionalPermaCacheStrategy","eth_getTransactionByHash","containsBlockhash","eth_getTransactionReceipt","block","BlockCacheStrategy","fork","PermaCacheStrategy","cache","timeout","setInterval","unref","conditionals","strategy","result","blockHash","hex","toBuffer","gt","module","exports","prototype","setEngine","engine","clearOldCache","newBlock","previousBlock","currentBlock","cacheRollOff","once","go","on","handleRequest","next","end","skipCache","method","params","await","_handleRequest","type","cacheTypeForPayload","canCache","requestedBlockNumber","blockTag","blockTagForPayload","bufferToHex","number","hitCheck","err","cb","cacheResult","hit","miss","identifier","cacheIdentifierForPayload","cached","hexA","hexB","numA","parseInt","numB","compareHex","blockNumber","callback","clonedValue","conditional","getBlockCacheForPayload","blockNumberHex","Number","blockCache","newCache","previousHex","oldBlockNumber","Object","keys","map","filter","num","forEach","_instanceof","obj","nativeMap","nativeSet","nativePromise","Map","Set","Promise","parent","circular","depth","includeNonEnumerable","allParents","allChildren","useBuffer","Buffer","Infinity","_clone","child","proto","resolve","reject","then","value","__isArray","__isRegExp","RegExp","source","__getRegExpFlags","lastIndex","__isDate","Date","getTime","isBuffer","allocUnsafe","length","copy","Error","create","getPrototypeOf","index","indexOf","push","i","key","keyChild","valueChild","set","entryChild","add","attrs","getOwnPropertyDescriptor","getOwnPropertySymbols","symbols","symbol","descriptor","enumerable","defineProperty","allPropertyNames","getOwnPropertyNames","propertyName","__objToStr","o","toString","call","re","flags","global","ignoreCase","multiline","clonePrototype","c","createPayload","SubProvider","emitPayload","sendAsync","LedgerConnector","chainId","url","pollingInterval","requestTimeoutMs","accountFetchingConfigs","baseDerivationPath","networkId","ledgerEthereumClientFactoryAsync","provider","e","accounts","deactivate"],"mappings":"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","file":"static/js/7.ff240804.chunk.js","sourcesContent":["import { ConnectorUpdate } from '@web3-react/types'\nimport { AbstractConnector } from '@web3-react/abstract-connector'\nimport Web3ProviderEngine from 'web3-provider-engine'\nimport { ledgerEthereumBrowserClientFactoryAsync } from '@0x/subproviders/lib/src' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport { LedgerSubprovider } from '@0x/subproviders/lib/src/subproviders/ledger' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport CacheSubprovider from 'web3-provider-engine/subproviders/cache.js'\nimport { RPCSubprovider } from '@0x/subproviders/lib/src/subproviders/rpc_subprovider' // https://github.com/0xProject/0x-monorepo/issues/1400\n\ninterface LedgerConnectorArguments {\n  chainId: number\n  url: string\n  pollingInterval?: number\n  requestTimeoutMs?: number\n  accountFetchingConfigs?: any\n  baseDerivationPath?: string\n}\n\nexport class LedgerConnector extends AbstractConnector {\n  private readonly chainId: number\n  private readonly url: string\n  private readonly pollingInterval?: number\n  private readonly requestTimeoutMs?: number\n  private readonly accountFetchingConfigs?: any\n  private readonly baseDerivationPath?: string\n\n  private provider: any\n\n  constructor({\n    chainId,\n    url,\n    pollingInterval,\n    requestTimeoutMs,\n    accountFetchingConfigs,\n    baseDerivationPath\n  }: LedgerConnectorArguments) {\n    super({ supportedChainIds: [chainId] })\n\n    this.chainId = chainId\n    this.url = url\n    this.pollingInterval = pollingInterval\n    this.requestTimeoutMs = requestTimeoutMs\n    this.accountFetchingConfigs = accountFetchingConfigs\n    this.baseDerivationPath = baseDerivationPath\n  }\n\n  public async activate(): Promise<ConnectorUpdate> {\n    if (!this.provider) {\n      const engine = new Web3ProviderEngine({ pollingInterval: this.pollingInterval })\n      engine.addProvider(\n        new LedgerSubprovider({\n          networkId: this.chainId,\n          ledgerEthereumClientFactoryAsync: ledgerEthereumBrowserClientFactoryAsync,\n          accountFetchingConfigs: this.accountFetchingConfigs,\n          baseDerivationPath: this.baseDerivationPath\n        })\n      )\n      engine.addProvider(new CacheSubprovider())\n      engine.addProvider(new RPCSubprovider(this.url, this.requestTimeoutMs))\n      this.provider = engine\n    }\n\n    this.provider.start()\n\n    return { provider: this.provider, chainId: this.chainId }\n  }\n\n  public async getProvider(): Promise<Web3ProviderEngine> {\n    return this.provider\n  }\n\n  public async getChainId(): Promise<number> {\n    return this.chainId\n  }\n\n  public async getAccount(): Promise<null> {\n    return this.provider._providers[0].getAccountsAsync(1).then((accounts: string[]): string => accounts[0])\n  }\n\n  public deactivate() {\n    this.provider.stop()\n  }\n}\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"@0x/utils\");\n/**\n * A altered version of the base class Subprovider found in [web3-provider-engine](https://github.com/MetaMask/provider-engine).\n * This one has an async/await `emitPayloadAsync` and also defined types.\n */\nvar Subprovider = /** @class */ (function () {\n    function Subprovider() {\n    }\n    Subprovider._createFinalPayload = function (payload) {\n        var finalPayload = __assign({ \n            // defaults\n            id: Subprovider._getRandomId(), jsonrpc: '2.0', params: [] }, payload);\n        return finalPayload;\n    };\n    // Ported from: https://github.com/MetaMask/provider-engine/blob/master/util/random-id.js\n    Subprovider._getRandomId = function () {\n        var extraDigits = 3;\n        var baseTen = 10;\n        // 13 time digits\n        var datePart = new Date().getTime() * Math.pow(baseTen, extraDigits);\n        // 3 random digits\n        var extraPart = Math.floor(Math.random() * Math.pow(baseTen, extraDigits));\n        // 16 digits\n        return datePart + extraPart;\n    };\n    /**\n     * Emits a JSON RPC payload that will then be handled by the ProviderEngine instance\n     * this subprovider is a part of. The payload will cascade down the subprovider middleware\n     * stack until finding the responsible entity for handling the request.\n     * @param payload JSON RPC payload\n     * @returns JSON RPC response payload\n     */\n    Subprovider.prototype.emitPayloadAsync = function (payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var finalPayload, response;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        finalPayload = Subprovider._createFinalPayload(payload);\n                        return [4 /*yield*/, utils_1.promisify(this.engine.sendAsync, this.engine)(finalPayload)];\n                    case 1:\n                        response = _a.sent();\n                        return [2 /*return*/, response];\n                }\n            });\n        });\n    };\n    /**\n     * Set's the subprovider's engine to the ProviderEngine it is added to.\n     * This is only called within the ProviderEngine source code, do not call\n     * directly.\n     * @param engine The ProviderEngine this subprovider is added to\n     */\n    Subprovider.prototype.setEngine = function (engine) {\n        this.engine = engine;\n    };\n    return Subprovider;\n}());\nexports.Subprovider = Subprovider;\n//# sourceMappingURL=subprovider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar WalletSubproviderErrors;\n(function (WalletSubproviderErrors) {\n    WalletSubproviderErrors[\"AddressNotFound\"] = \"ADDRESS_NOT_FOUND\";\n    WalletSubproviderErrors[\"DataMissingForSignPersonalMessage\"] = \"DATA_MISSING_FOR_SIGN_PERSONAL_MESSAGE\";\n    WalletSubproviderErrors[\"DataMissingForSignTypedData\"] = \"DATA_MISSING_FOR_SIGN_TYPED_DATA\";\n    WalletSubproviderErrors[\"SenderInvalidOrNotSupplied\"] = \"SENDER_INVALID_OR_NOT_SUPPLIED\";\n    WalletSubproviderErrors[\"FromAddressMissingOrInvalid\"] = \"FROM_ADDRESS_MISSING_OR_INVALID\";\n    WalletSubproviderErrors[\"MethodNotSupported\"] = \"METHOD_NOT_SUPPORTED\";\n})(WalletSubproviderErrors = exports.WalletSubproviderErrors || (exports.WalletSubproviderErrors = {}));\nvar LedgerSubproviderErrors;\n(function (LedgerSubproviderErrors) {\n    LedgerSubproviderErrors[\"TooOldLedgerFirmware\"] = \"TOO_OLD_LEDGER_FIRMWARE\";\n    LedgerSubproviderErrors[\"MultipleOpenConnectionsDisallowed\"] = \"MULTIPLE_OPEN_CONNECTIONS_DISALLOWED\";\n})(LedgerSubproviderErrors = exports.LedgerSubproviderErrors || (exports.LedgerSubproviderErrors = {}));\nvar NonceSubproviderErrors;\n(function (NonceSubproviderErrors) {\n    NonceSubproviderErrors[\"EmptyParametersFound\"] = \"EMPTY_PARAMETERS_FOUND\";\n    NonceSubproviderErrors[\"CannotDetermineAddressFromPayload\"] = \"CANNOT_DETERMINE_ADDRESS_FROM_PAYLOAD\";\n})(NonceSubproviderErrors = exports.NonceSubproviderErrors || (exports.NonceSubproviderErrors = {}));\n//# sourceMappingURL=types.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"@0x/assert\");\nvar utils_1 = require(\"@0x/utils\");\nvar types_1 = require(\"../types\");\nvar subprovider_1 = require(\"./subprovider\");\nvar BaseWalletSubprovider = /** @class */ (function (_super) {\n    __extends(BaseWalletSubprovider, _super);\n    function BaseWalletSubprovider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    BaseWalletSubprovider._validateTxParams = function (txParams) {\n        if (txParams.to !== undefined) {\n            assert_1.assert.isETHAddressHex('to', txParams.to);\n        }\n        assert_1.assert.isHexString('nonce', txParams.nonce);\n    };\n    BaseWalletSubprovider._validateSender = function (sender) {\n        if (sender === undefined || !utils_1.addressUtils.isAddress(sender)) {\n            throw new Error(types_1.WalletSubproviderErrors.SenderInvalidOrNotSupplied);\n        }\n    };\n    /**\n     * This method conforms to the web3-provider-engine interface.\n     * It is called internally by the ProviderEngine when it is this subproviders\n     * turn to handle a JSON RPC request.\n     * @param payload JSON RPC payload\n     * @param next Callback to call if this subprovider decides not to handle the request\n     * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n     */\n    // tslint:disable-next-line:async-suffix\n    BaseWalletSubprovider.prototype.handleRequest = function (payload, next, end) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, accounts, txParams, address, typedData, _b, err_1, err_2, filledParams, signedTx, response, err_3, filledParams, signedTx, result, err_4, data, ecSignatureHex, err_5, signature, err_6;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _b = payload.method;\n                        switch (_b) {\n                            case 'eth_coinbase': return [3 /*break*/, 1];\n                            case 'eth_accounts': return [3 /*break*/, 5];\n                            case 'eth_sendTransaction': return [3 /*break*/, 9];\n                            case 'eth_signTransaction': return [3 /*break*/, 16];\n                            case 'eth_sign': return [3 /*break*/, 22];\n                            case 'personal_sign': return [3 /*break*/, 22];\n                            case 'eth_signTypedData': return [3 /*break*/, 27];\n                        }\n                        return [3 /*break*/, 32];\n                    case 1:\n                        _c.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.getAccountsAsync()];\n                    case 2:\n                        accounts = _c.sent();\n                        end(null, accounts[0]);\n                        return [3 /*break*/, 4];\n                    case 3:\n                        err_1 = _c.sent();\n                        end(err_1);\n                        return [3 /*break*/, 4];\n                    case 4: return [2 /*return*/];\n                    case 5:\n                        _c.trys.push([5, 7, , 8]);\n                        return [4 /*yield*/, this.getAccountsAsync()];\n                    case 6:\n                        accounts = _c.sent();\n                        end(null, accounts);\n                        return [3 /*break*/, 8];\n                    case 7:\n                        err_2 = _c.sent();\n                        end(err_2);\n                        return [3 /*break*/, 8];\n                    case 8: return [2 /*return*/];\n                    case 9:\n                        txParams = payload.params[0];\n                        _c.label = 10;\n                    case 10:\n                        _c.trys.push([10, 14, , 15]);\n                        BaseWalletSubprovider._validateSender(txParams.from);\n                        return [4 /*yield*/, this._populateMissingTxParamsAsync(txParams)];\n                    case 11:\n                        filledParams = _c.sent();\n                        return [4 /*yield*/, this.signTransactionAsync(filledParams)];\n                    case 12:\n                        signedTx = _c.sent();\n                        return [4 /*yield*/, this._emitSendTransactionAsync(signedTx)];\n                    case 13:\n                        response = _c.sent();\n                        end(null, response.result);\n                        return [3 /*break*/, 15];\n                    case 14:\n                        err_3 = _c.sent();\n                        end(err_3);\n                        return [3 /*break*/, 15];\n                    case 15: return [2 /*return*/];\n                    case 16:\n                        txParams = payload.params[0];\n                        _c.label = 17;\n                    case 17:\n                        _c.trys.push([17, 20, , 21]);\n                        return [4 /*yield*/, this._populateMissingTxParamsAsync(txParams)];\n                    case 18:\n                        filledParams = _c.sent();\n                        return [4 /*yield*/, this.signTransactionAsync(filledParams)];\n                    case 19:\n                        signedTx = _c.sent();\n                        result = {\n                            raw: signedTx,\n                            tx: txParams,\n                        };\n                        end(null, result);\n                        return [3 /*break*/, 21];\n                    case 20:\n                        err_4 = _c.sent();\n                        end(err_4);\n                        return [3 /*break*/, 21];\n                    case 21: return [2 /*return*/];\n                    case 22:\n                        data = payload.method === 'eth_sign' ? payload.params[1] : payload.params[0];\n                        address = payload.method === 'eth_sign' ? payload.params[0] : payload.params[1];\n                        _c.label = 23;\n                    case 23:\n                        _c.trys.push([23, 25, , 26]);\n                        return [4 /*yield*/, this.signPersonalMessageAsync(data, address)];\n                    case 24:\n                        ecSignatureHex = _c.sent();\n                        end(null, ecSignatureHex);\n                        return [3 /*break*/, 26];\n                    case 25:\n                        err_5 = _c.sent();\n                        end(err_5);\n                        return [3 /*break*/, 26];\n                    case 26: return [2 /*return*/];\n                    case 27:\n                        _a = __read(payload.params, 2), address = _a[0], typedData = _a[1];\n                        _c.label = 28;\n                    case 28:\n                        _c.trys.push([28, 30, , 31]);\n                        return [4 /*yield*/, this.signTypedDataAsync(address, typedData)];\n                    case 29:\n                        signature = _c.sent();\n                        end(null, signature);\n                        return [3 /*break*/, 31];\n                    case 30:\n                        err_6 = _c.sent();\n                        end(err_6);\n                        return [3 /*break*/, 31];\n                    case 31: return [2 /*return*/];\n                    case 32:\n                        next();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseWalletSubprovider.prototype._emitSendTransactionAsync = function (signedTx) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        payload = {\n                            method: 'eth_sendRawTransaction',\n                            params: [signedTx],\n                        };\n                        return [4 /*yield*/, this.emitPayloadAsync(payload)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    BaseWalletSubprovider.prototype._populateMissingTxParamsAsync = function (partialTxParams) {\n        return __awaiter(this, void 0, void 0, function () {\n            var txParams, gasPriceResult, gasPrice, nonceResult, nonce, gasResult, gas;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        txParams = partialTxParams;\n                        if (!(partialTxParams.gasPrice === undefined)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.emitPayloadAsync({\n                                method: 'eth_gasPrice',\n                                params: [],\n                            })];\n                    case 1:\n                        gasPriceResult = _a.sent();\n                        gasPrice = gasPriceResult.result.toString();\n                        txParams = __assign({}, txParams, { gasPrice: gasPrice });\n                        _a.label = 2;\n                    case 2:\n                        if (!(partialTxParams.nonce === undefined)) return [3 /*break*/, 4];\n                        return [4 /*yield*/, this.emitPayloadAsync({\n                                method: 'eth_getTransactionCount',\n                                params: [partialTxParams.from, 'pending'],\n                            })];\n                    case 3:\n                        nonceResult = _a.sent();\n                        nonce = nonceResult.result;\n                        txParams = __assign({}, txParams, { nonce: nonce });\n                        _a.label = 4;\n                    case 4:\n                        if (!(partialTxParams.gas === undefined)) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this.emitPayloadAsync({\n                                method: 'eth_estimateGas',\n                                params: [partialTxParams],\n                            })];\n                    case 5:\n                        gasResult = _a.sent();\n                        gas = gasResult.result.toString();\n                        txParams = __assign({}, txParams, { gas: gas });\n                        _a.label = 6;\n                    case 6: return [2 /*return*/, txParams];\n                }\n            });\n        });\n    };\n    return BaseWalletSubprovider;\n}(subprovider_1.Subprovider));\nexports.BaseWalletSubprovider = BaseWalletSubprovider;\n//# sourceMappingURL=base_wallet_subprovider.js.map","\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethUtil = require(\"ethereumjs-util\");\nvar DEFAULT_ADDRESS_SEARCH_LIMIT = 1000;\nvar DerivedHDKeyInfoIterator = /** @class */ (function () {\n    function DerivedHDKeyInfoIterator(initialDerivedKey, searchLimit) {\n        if (searchLimit === void 0) { searchLimit = DEFAULT_ADDRESS_SEARCH_LIMIT; }\n        this._searchLimit = searchLimit;\n        this._parentDerivedKeyInfo = initialDerivedKey;\n        this._index = 0;\n    }\n    DerivedHDKeyInfoIterator.prototype.next = function () {\n        var baseDerivationPath = this._parentDerivedKeyInfo.baseDerivationPath;\n        var derivationIndex = this._index;\n        var fullDerivationPath = \"m/\" + baseDerivationPath + \"/\" + derivationIndex;\n        var path = \"m/\" + derivationIndex;\n        var hdKey = this._parentDerivedKeyInfo.hdKey.derive(path);\n        var address = exports.walletUtils.addressOfHDKey(hdKey);\n        var derivedKey = {\n            address: address,\n            hdKey: hdKey,\n            baseDerivationPath: baseDerivationPath,\n            derivationPath: fullDerivationPath,\n        };\n        var isDone = this._index === this._searchLimit;\n        this._index++;\n        return {\n            done: isDone,\n            value: derivedKey,\n        };\n    };\n    DerivedHDKeyInfoIterator.prototype[Symbol.iterator] = function () {\n        return this;\n    };\n    return DerivedHDKeyInfoIterator;\n}());\nexports.walletUtils = {\n    calculateDerivedHDKeyInfos: function (parentDerivedKeyInfo, numberOfKeys) {\n        var e_1, _a;\n        var derivedKeys = [];\n        var derivedKeyIterator = new DerivedHDKeyInfoIterator(parentDerivedKeyInfo, numberOfKeys);\n        try {\n            for (var derivedKeyIterator_1 = __values(derivedKeyIterator), derivedKeyIterator_1_1 = derivedKeyIterator_1.next(); !derivedKeyIterator_1_1.done; derivedKeyIterator_1_1 = derivedKeyIterator_1.next()) {\n                var key = derivedKeyIterator_1_1.value;\n                derivedKeys.push(key);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (derivedKeyIterator_1_1 && !derivedKeyIterator_1_1.done && (_a = derivedKeyIterator_1.return)) _a.call(derivedKeyIterator_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return derivedKeys;\n    },\n    findDerivedKeyInfoForAddressIfExists: function (address, parentDerivedKeyInfo, searchLimit) {\n        var e_2, _a;\n        var lowercaseAddress = address.toLowerCase();\n        var matchedKey;\n        var derivedKeyIterator = new DerivedHDKeyInfoIterator(parentDerivedKeyInfo, searchLimit);\n        try {\n            for (var derivedKeyIterator_2 = __values(derivedKeyIterator), derivedKeyIterator_2_1 = derivedKeyIterator_2.next(); !derivedKeyIterator_2_1.done; derivedKeyIterator_2_1 = derivedKeyIterator_2.next()) {\n                var key = derivedKeyIterator_2_1.value;\n                if (key.address === lowercaseAddress) {\n                    matchedKey = key;\n                    break;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (derivedKeyIterator_2_1 && !derivedKeyIterator_2_1.done && (_a = derivedKeyIterator_2.return)) _a.call(derivedKeyIterator_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return matchedKey;\n    },\n    addressOfHDKey: function (hdKey) {\n        var shouldSanitizePublicKey = true;\n        var derivedPublicKey = hdKey.publicKey;\n        var ethereumAddressUnprefixed = ethUtil\n            .publicToAddress(derivedPublicKey, shouldSanitizePublicKey)\n            .toString('hex');\n        var address = ethUtil.addHexPrefix(ethereumAddressUnprefixed).toLowerCase();\n        return address;\n    },\n};\n//# sourceMappingURL=wallet_utils.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"@0x/assert\");\nvar utils_1 = require(\"@0x/utils\");\nvar EthereumTx = require(\"ethereumjs-tx\");\nvar ethUtil = require(\"ethereumjs-util\");\nvar HDNode = require(\"hdkey\");\nvar _ = require(\"lodash\");\nvar semaphore_async_await_1 = require(\"semaphore-async-await\");\nvar types_1 = require(\"../types\");\nvar wallet_utils_1 = require(\"../utils/wallet_utils\");\nvar base_wallet_subprovider_1 = require(\"./base_wallet_subprovider\");\nvar DEFAULT_BASE_DERIVATION_PATH = \"44'/60'/0'\";\nvar ASK_FOR_ON_DEVICE_CONFIRMATION = false;\nvar SHOULD_GET_CHAIN_CODE = true;\nvar DEFAULT_NUM_ADDRESSES_TO_FETCH = 10;\nvar DEFAULT_ADDRESS_SEARCH_LIMIT = 1000;\n/**\n * Subprovider for interfacing with a user's [Ledger Nano S](https://www.ledgerwallet.com/products/ledger-nano-s).\n * This subprovider intercepts all account related RPC requests (e.g message/transaction signing, etc...) and\n * re-routes them to a Ledger device plugged into the users computer.\n */\nvar LedgerSubprovider = /** @class */ (function (_super) {\n    __extends(LedgerSubprovider, _super);\n    /**\n     * Instantiates a LedgerSubprovider. Defaults to derivationPath set to `44'/60'/0'`.\n     * TestRPC/Ganache defaults to `m/44'/60'/0'/0`, so set this in the configs if desired.\n     * @param config Several available configurations\n     * @return LedgerSubprovider instance\n     */\n    function LedgerSubprovider(config) {\n        var _this = _super.call(this) || this;\n        // tslint:disable-next-line:no-unused-variable\n        _this._connectionLock = new semaphore_async_await_1.Lock();\n        _this._networkId = config.networkId;\n        _this._ledgerEthereumClientFactoryAsync = config.ledgerEthereumClientFactoryAsync;\n        _this._baseDerivationPath = config.baseDerivationPath || DEFAULT_BASE_DERIVATION_PATH;\n        _this._shouldAlwaysAskForConfirmation =\n            config.accountFetchingConfigs !== undefined &&\n                config.accountFetchingConfigs.shouldAskForOnDeviceConfirmation !== undefined\n                ? config.accountFetchingConfigs.shouldAskForOnDeviceConfirmation\n                : ASK_FOR_ON_DEVICE_CONFIRMATION;\n        _this._addressSearchLimit =\n            config.accountFetchingConfigs !== undefined &&\n                config.accountFetchingConfigs.addressSearchLimit !== undefined\n                ? config.accountFetchingConfigs.addressSearchLimit\n                : DEFAULT_ADDRESS_SEARCH_LIMIT;\n        return _this;\n    }\n    /**\n     * Retrieve the set derivation path\n     * @returns derivation path\n     */\n    LedgerSubprovider.prototype.getPath = function () {\n        return this._baseDerivationPath;\n    };\n    /**\n     * Set a desired derivation path when computing the available user addresses\n     * @param basDerivationPath The desired derivation path (e.g `44'/60'/0'`)\n     */\n    LedgerSubprovider.prototype.setPath = function (basDerivationPath) {\n        this._baseDerivationPath = basDerivationPath;\n    };\n    /**\n     * Retrieve a users Ledger accounts. The accounts are derived from the derivationPath,\n     * master public key and chain code. Because of this, you can request as many accounts\n     * as you wish and it only requires a single request to the Ledger device. This method\n     * is automatically called when issuing a `eth_accounts` JSON RPC request via your providerEngine\n     * instance.\n     * @param numberOfAccounts Number of accounts to retrieve (default: 10)\n     * @return An array of accounts\n     */\n    LedgerSubprovider.prototype.getAccountsAsync = function (numberOfAccounts) {\n        if (numberOfAccounts === void 0) { numberOfAccounts = DEFAULT_NUM_ADDRESSES_TO_FETCH; }\n        return __awaiter(this, void 0, void 0, function () {\n            var initialDerivedKeyInfo, derivedKeyInfos, accounts;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._initialDerivedKeyInfoAsync()];\n                    case 1:\n                        initialDerivedKeyInfo = _a.sent();\n                        derivedKeyInfos = wallet_utils_1.walletUtils.calculateDerivedHDKeyInfos(initialDerivedKeyInfo, numberOfAccounts);\n                        accounts = _.map(derivedKeyInfos, function (k) { return k.address; });\n                        return [2 /*return*/, accounts];\n                }\n            });\n        });\n    };\n    /**\n     * Signs a transaction on the Ledger with the account specificed by the `from` field in txParams.\n     * If you've added the LedgerSubprovider to your app's provider, you can simply send an `eth_sendTransaction`\n     * JSON RPC request, and this method will be called auto-magically. If you are not using this via a ProviderEngine\n     * instance, you can call it directly.\n     * @param txParams Parameters of the transaction to sign\n     * @return Signed transaction hex string\n     */\n    LedgerSubprovider.prototype.signTransactionAsync = function (txParams) {\n        return __awaiter(this, void 0, void 0, function () {\n            var initialDerivedKeyInfo, derivedKeyInfo, _a, tx, vIndex, rIndex, sIndex, txHex, fullDerivationPath, result, eip55Constant, signedChainId, err, signedTxHex, err_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        LedgerSubprovider._validateTxParams(txParams);\n                        if (txParams.from === undefined || !utils_1.addressUtils.isAddress(txParams.from)) {\n                            throw new Error(types_1.WalletSubproviderErrors.FromAddressMissingOrInvalid);\n                        }\n                        return [4 /*yield*/, this._initialDerivedKeyInfoAsync()];\n                    case 1:\n                        initialDerivedKeyInfo = _b.sent();\n                        derivedKeyInfo = this._findDerivedKeyInfoForAddress(initialDerivedKeyInfo, txParams.from);\n                        _a = this;\n                        return [4 /*yield*/, this._createLedgerClientAsync()];\n                    case 2:\n                        _a._ledgerClientIfExists = _b.sent();\n                        tx = new EthereumTx(txParams);\n                        vIndex = 6;\n                        tx.raw[vIndex] = Buffer.from([this._networkId]); // v\n                        rIndex = 7;\n                        tx.raw[rIndex] = Buffer.from([]); // r\n                        sIndex = 8;\n                        tx.raw[sIndex] = Buffer.from([]); // s\n                        txHex = tx.serialize().toString('hex');\n                        _b.label = 3;\n                    case 3:\n                        _b.trys.push([3, 8, , 10]);\n                        fullDerivationPath = derivedKeyInfo.derivationPath;\n                        return [4 /*yield*/, this._ledgerClientIfExists.signTransaction(fullDerivationPath, txHex)];\n                    case 4:\n                        result = _b.sent();\n                        // Store signature in transaction\n                        tx.r = Buffer.from(result.r, 'hex');\n                        tx.s = Buffer.from(result.s, 'hex');\n                        tx.v = Buffer.from(result.v, 'hex');\n                        eip55Constant = 35;\n                        signedChainId = Math.floor((tx.v[0] - eip55Constant) / 2);\n                        if (!(signedChainId !== this._networkId)) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this._destroyLedgerClientAsync()];\n                    case 5:\n                        _b.sent();\n                        err = new Error(types_1.LedgerSubproviderErrors.TooOldLedgerFirmware);\n                        throw err;\n                    case 6:\n                        signedTxHex = \"0x\" + tx.serialize().toString('hex');\n                        return [4 /*yield*/, this._destroyLedgerClientAsync()];\n                    case 7:\n                        _b.sent();\n                        return [2 /*return*/, signedTxHex];\n                    case 8:\n                        err_1 = _b.sent();\n                        return [4 /*yield*/, this._destroyLedgerClientAsync()];\n                    case 9:\n                        _b.sent();\n                        throw err_1;\n                    case 10: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Sign a personal Ethereum signed message. The signing account will be the account\n     * associated with the provided address.\n     * The Ledger adds the Ethereum signed message prefix on-device.  If you've added\n     * the LedgerSubprovider to your app's provider, you can simply send an `eth_sign`\n     * or `personal_sign` JSON RPC request, and this method will be called auto-magically.\n     * If you are not using this via a ProviderEngine instance, you can call it directly.\n     * @param data Hex string message to sign\n     * @param address Address of the account to sign with\n     * @return Signature hex string (order: rsv)\n     */\n    LedgerSubprovider.prototype.signPersonalMessageAsync = function (data, address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var initialDerivedKeyInfo, derivedKeyInfo, _a, fullDerivationPath, result, lowestValidV, v, hexBase, vHex, signature, err_2;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (data === undefined) {\n                            throw new Error(types_1.WalletSubproviderErrors.DataMissingForSignPersonalMessage);\n                        }\n                        assert_1.assert.isHexString('data', data);\n                        assert_1.assert.isETHAddressHex('address', address);\n                        return [4 /*yield*/, this._initialDerivedKeyInfoAsync()];\n                    case 1:\n                        initialDerivedKeyInfo = _b.sent();\n                        derivedKeyInfo = this._findDerivedKeyInfoForAddress(initialDerivedKeyInfo, address);\n                        _a = this;\n                        return [4 /*yield*/, this._createLedgerClientAsync()];\n                    case 2:\n                        _a._ledgerClientIfExists = _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _b.trys.push([3, 6, , 8]);\n                        fullDerivationPath = derivedKeyInfo.derivationPath;\n                        return [4 /*yield*/, this._ledgerClientIfExists.signPersonalMessage(fullDerivationPath, ethUtil.stripHexPrefix(data))];\n                    case 4:\n                        result = _b.sent();\n                        lowestValidV = 27;\n                        v = result.v - lowestValidV;\n                        hexBase = 16;\n                        vHex = v.toString(hexBase);\n                        if (vHex.length < 2) {\n                            vHex = \"0\" + v;\n                        }\n                        signature = \"0x\" + result.r + result.s + vHex;\n                        return [4 /*yield*/, this._destroyLedgerClientAsync()];\n                    case 5:\n                        _b.sent();\n                        return [2 /*return*/, signature];\n                    case 6:\n                        err_2 = _b.sent();\n                        return [4 /*yield*/, this._destroyLedgerClientAsync()];\n                    case 7:\n                        _b.sent();\n                        throw err_2;\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * eth_signTypedData is currently not supported on Ledger devices.\n     * @param address Address of the account to sign with\n     * @param data the typed data object\n     * @return Signature hex string (order: rsv)\n     */\n    // tslint:disable-next-line:prefer-function-over-method\n    LedgerSubprovider.prototype.signTypedDataAsync = function (address, typedData) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                throw new Error(types_1.WalletSubproviderErrors.MethodNotSupported);\n            });\n        });\n    };\n    LedgerSubprovider.prototype._createLedgerClientAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var ledgerEthereumClient;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._connectionLock.acquire()];\n                    case 1:\n                        _a.sent();\n                        if (this._ledgerClientIfExists !== undefined) {\n                            this._connectionLock.release();\n                            throw new Error(types_1.LedgerSubproviderErrors.MultipleOpenConnectionsDisallowed);\n                        }\n                        return [4 /*yield*/, this._ledgerEthereumClientFactoryAsync()];\n                    case 2:\n                        ledgerEthereumClient = _a.sent();\n                        this._connectionLock.release();\n                        return [2 /*return*/, ledgerEthereumClient];\n                }\n            });\n        });\n    };\n    LedgerSubprovider.prototype._destroyLedgerClientAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._connectionLock.acquire()];\n                    case 1:\n                        _a.sent();\n                        if (this._ledgerClientIfExists === undefined) {\n                            this._connectionLock.release();\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, this._ledgerClientIfExists.transport.close()];\n                    case 2:\n                        _a.sent();\n                        this._ledgerClientIfExists = undefined;\n                        this._connectionLock.release();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    LedgerSubprovider.prototype._initialDerivedKeyInfoAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, parentKeyDerivationPath, ledgerResponse, hdKey, address, initialDerivedKeyInfo;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this;\n                        return [4 /*yield*/, this._createLedgerClientAsync()];\n                    case 1:\n                        _a._ledgerClientIfExists = _b.sent();\n                        parentKeyDerivationPath = \"m/\" + this._baseDerivationPath;\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, , 4, 6]);\n                        return [4 /*yield*/, this._ledgerClientIfExists.getAddress(parentKeyDerivationPath, this._shouldAlwaysAskForConfirmation, SHOULD_GET_CHAIN_CODE)];\n                    case 3:\n                        ledgerResponse = _b.sent();\n                        return [3 /*break*/, 6];\n                    case 4: return [4 /*yield*/, this._destroyLedgerClientAsync()];\n                    case 5:\n                        _b.sent();\n                        return [7 /*endfinally*/];\n                    case 6:\n                        hdKey = new HDNode();\n                        hdKey.publicKey = new Buffer(ledgerResponse.publicKey, 'hex');\n                        hdKey.chainCode = new Buffer(ledgerResponse.chainCode, 'hex');\n                        address = wallet_utils_1.walletUtils.addressOfHDKey(hdKey);\n                        initialDerivedKeyInfo = {\n                            hdKey: hdKey,\n                            address: address,\n                            derivationPath: parentKeyDerivationPath,\n                            baseDerivationPath: this._baseDerivationPath,\n                        };\n                        return [2 /*return*/, initialDerivedKeyInfo];\n                }\n            });\n        });\n    };\n    LedgerSubprovider.prototype._findDerivedKeyInfoForAddress = function (initalHDKey, address) {\n        var matchedDerivedKeyInfo = wallet_utils_1.walletUtils.findDerivedKeyInfoForAddressIfExists(address, initalHDKey, this._addressSearchLimit);\n        if (matchedDerivedKeyInfo === undefined) {\n            throw new Error(types_1.WalletSubproviderErrors.AddressNotFound + \": \" + address);\n        }\n        return matchedDerivedKeyInfo;\n    };\n    return LedgerSubprovider;\n}(base_wallet_subprovider_1.BaseWalletSubprovider));\nexports.LedgerSubprovider = LedgerSubprovider;\n//# sourceMappingURL=ledger.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"@0x/assert\");\nvar types_1 = require(\"@0x/types\");\nvar utils_1 = require(\"@0x/utils\");\nvar JsonRpcError = require(\"json-rpc-error\");\nvar subprovider_1 = require(\"./subprovider\");\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine) subprovider interface.\n * It forwards on JSON RPC requests to the supplied `rpcUrl` endpoint\n */\nvar RPCSubprovider = /** @class */ (function (_super) {\n    __extends(RPCSubprovider, _super);\n    /**\n     * @param rpcUrl URL to the backing Ethereum node to which JSON RPC requests should be sent\n     * @param requestTimeoutMs Amount of miliseconds to wait before timing out the JSON RPC request\n     */\n    function RPCSubprovider(rpcUrl, requestTimeoutMs) {\n        if (requestTimeoutMs === void 0) { requestTimeoutMs = 20000; }\n        var _this = _super.call(this) || this;\n        assert_1.assert.isString('rpcUrl', rpcUrl);\n        assert_1.assert.isNumber('requestTimeoutMs', requestTimeoutMs);\n        _this._rpcUrl = rpcUrl;\n        _this._requestTimeoutMs = requestTimeoutMs;\n        return _this;\n    }\n    /**\n     * This method conforms to the web3-provider-engine interface.\n     * It is called internally by the ProviderEngine when it is this subproviders\n     * turn to handle a JSON RPC request.\n     * @param payload JSON RPC payload\n     * @param _next Callback to call if this subprovider decides not to handle the request\n     * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n     */\n    // tslint:disable-next-line:prefer-function-over-method async-suffix\n    RPCSubprovider.prototype.handleRequest = function (payload, _next, end) {\n        return __awaiter(this, void 0, void 0, function () {\n            var finalPayload, headers, response, err_1, text, statusCode, errMsg, err, data;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        finalPayload = subprovider_1.Subprovider._createFinalPayload(payload);\n                        headers = new Headers({\n                            Accept: 'application/json',\n                            'Content-Type': 'application/json',\n                        });\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, utils_1.fetchAsync(this._rpcUrl, {\n                                method: 'POST',\n                                headers: headers,\n                                body: JSON.stringify(finalPayload),\n                            }, this._requestTimeoutMs)];\n                    case 2:\n                        response = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        err_1 = _a.sent();\n                        end(new JsonRpcError.InternalError(err_1));\n                        return [2 /*return*/];\n                    case 4: return [4 /*yield*/, response.text()];\n                    case 5:\n                        text = _a.sent();\n                        if (!response.ok) {\n                            statusCode = response.status;\n                            switch (statusCode) {\n                                case types_1.StatusCodes.MethodNotAllowed:\n                                    end(new JsonRpcError.MethodNotFound());\n                                    return [2 /*return*/];\n                                case types_1.StatusCodes.GatewayTimeout:\n                                    errMsg = 'Gateway timeout. The request took too long to process. This can happen when querying logs over too wide a block range.';\n                                    err = new Error(errMsg);\n                                    end(new JsonRpcError.InternalError(err));\n                                    return [2 /*return*/];\n                                default:\n                                    end(new JsonRpcError.InternalError(text));\n                                    return [2 /*return*/];\n                            }\n                        }\n                        try {\n                            data = JSON.parse(text);\n                        }\n                        catch (err) {\n                            end(new JsonRpcError.InternalError(err));\n                            return [2 /*return*/];\n                        }\n                        if (data.error) {\n                            end(data.error);\n                            return [2 /*return*/];\n                        }\n                        end(null, data.result);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return RPCSubprovider;\n}(subprovider_1.Subprovider));\nexports.RPCSubprovider = RPCSubprovider;\n//# sourceMappingURL=rpc_subprovider.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"@0x/assert\");\nvar utils_1 = require(\"@0x/utils\");\nvar EthereumTx = require(\"ethereumjs-tx\");\nvar ethUtil = require(\"ethereumjs-util\");\nvar types_1 = require(\"../types\");\nvar base_wallet_subprovider_1 = require(\"./base_wallet_subprovider\");\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine) subprovider interface.\n * This subprovider intercepts all account related RPC requests (e.g message/transaction signing, etc...) and handles\n * all requests with the supplied Ethereum private key.\n */\nvar PrivateKeyWalletSubprovider = /** @class */ (function (_super) {\n    __extends(PrivateKeyWalletSubprovider, _super);\n    /**\n     * Instantiates a PrivateKeyWalletSubprovider.\n     * @param privateKey The corresponding private key to an Ethereum address\n     * @return PrivateKeyWalletSubprovider instance\n     */\n    function PrivateKeyWalletSubprovider(privateKey) {\n        var _this = this;\n        assert_1.assert.isString('privateKey', privateKey);\n        _this = _super.call(this) || this;\n        _this._privateKeyBuffer = Buffer.from(privateKey, 'hex');\n        _this._address = \"0x\" + ethUtil.privateToAddress(_this._privateKeyBuffer).toString('hex');\n        return _this;\n    }\n    /**\n     * Retrieve the account associated with the supplied private key.\n     * This method is implicitly called when issuing a `eth_accounts` JSON RPC request\n     * via your providerEngine instance.\n     * @return An array of accounts\n     */\n    PrivateKeyWalletSubprovider.prototype.getAccountsAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, [this._address]];\n            });\n        });\n    };\n    /**\n     * Sign a transaction with the private key. If you've added this Subprovider to your\n     * app's provider, you can simply send an `eth_sendTransaction` JSON RPC request, and\n     * this method will be called auto-magically. If you are not using this via a ProviderEngine\n     * instance, you can call it directly.\n     * @param txParams Parameters of the transaction to sign\n     * @return Signed transaction hex string\n     */\n    PrivateKeyWalletSubprovider.prototype.signTransactionAsync = function (txParams) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tx, rawTx;\n            return __generator(this, function (_a) {\n                PrivateKeyWalletSubprovider._validateTxParams(txParams);\n                if (txParams.from !== undefined && txParams.from.toLowerCase() !== this._address.toLowerCase()) {\n                    throw new Error(\"Requested to sign transaction with address: \" + txParams.from + \", instantiated with address: \" + this._address);\n                }\n                tx = new EthereumTx(txParams);\n                tx.sign(this._privateKeyBuffer);\n                rawTx = \"0x\" + tx.serialize().toString('hex');\n                return [2 /*return*/, rawTx];\n            });\n        });\n    };\n    /**\n     * Sign a personal Ethereum signed message. The signing address will be calculated from the private key.\n     * The address must be provided it must match the address calculated from the private key.\n     * If you've added this Subprovider to your app's provider, you can simply send an `eth_sign`\n     * or `personal_sign` JSON RPC request, and this method will be called auto-magically.\n     * If you are not using this via a ProviderEngine instance, you can call it directly.\n     * @param data Hex string message to sign\n     * @param address Address of the account to sign with\n     * @return Signature hex string (order: rsv)\n     */\n    PrivateKeyWalletSubprovider.prototype.signPersonalMessageAsync = function (data, address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var dataBuff, msgHashBuff, sig, rpcSig;\n            return __generator(this, function (_a) {\n                if (data === undefined) {\n                    throw new Error(types_1.WalletSubproviderErrors.DataMissingForSignPersonalMessage);\n                }\n                assert_1.assert.isHexString('data', data);\n                assert_1.assert.isETHAddressHex('address', address);\n                if (address !== this._address) {\n                    throw new Error(\"Requested to sign message with address: \" + address + \", instantiated with address: \" + this._address);\n                }\n                dataBuff = ethUtil.toBuffer(data);\n                msgHashBuff = ethUtil.hashPersonalMessage(dataBuff);\n                sig = ethUtil.ecsign(msgHashBuff, this._privateKeyBuffer);\n                rpcSig = ethUtil.toRpcSig(sig.v, sig.r, sig.s);\n                return [2 /*return*/, rpcSig];\n            });\n        });\n    };\n    /**\n     * Sign an EIP712 Typed Data message. The signing address will be calculated from the private key.\n     * The address must be provided it must match the address calculated from the private key.\n     * If you've added this Subprovider to your app's provider, you can simply send an `eth_signTypedData`\n     * JSON RPC request, and this method will be called auto-magically.\n     * If you are not using this via a ProviderEngine instance, you can call it directly.\n     * @param address Address of the account to sign with\n     * @param data the typed data object\n     * @return Signature hex string (order: rsv)\n     */\n    PrivateKeyWalletSubprovider.prototype.signTypedDataAsync = function (address, typedData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var dataBuff, sig, rpcSig;\n            return __generator(this, function (_a) {\n                if (typedData === undefined) {\n                    throw new Error(types_1.WalletSubproviderErrors.DataMissingForSignTypedData);\n                }\n                assert_1.assert.isETHAddressHex('address', address);\n                if (address !== this._address) {\n                    throw new Error(\"Requested to sign message with address: \" + address + \", instantiated with address: \" + this._address);\n                }\n                dataBuff = utils_1.signTypedDataUtils.generateTypedDataHash(typedData);\n                sig = ethUtil.ecsign(dataBuff, this._privateKeyBuffer);\n                rpcSig = ethUtil.toRpcSig(sig.v, sig.r, sig.s);\n                return [2 /*return*/, rpcSig];\n            });\n        });\n    };\n    return PrivateKeyWalletSubprovider;\n}(base_wallet_subprovider_1.BaseWalletSubprovider));\nexports.PrivateKeyWalletSubprovider = PrivateKeyWalletSubprovider;\n//# sourceMappingURL=private_key_wallet.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar hw_app_eth_1 = require(\"@ledgerhq/hw-app-eth\");\nvar hw_transport_u2f_1 = require(\"@ledgerhq/hw-transport-u2f\");\nexports.Web3ProviderEngine = require(\"web3-provider-engine\");\n/**\n * A factory method for creating a LedgerEthereumClient usable in a browser context.\n * @return LedgerEthereumClient A browser client for the LedgerSubprovider\n */\nfunction ledgerEthereumBrowserClientFactoryAsync() {\n    return __awaiter(this, void 0, void 0, function () {\n        var ledgerConnection, ledgerEthClient;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, hw_transport_u2f_1.default.create()];\n                case 1:\n                    ledgerConnection = _a.sent();\n                    ledgerEthClient = new hw_app_eth_1.default(ledgerConnection);\n                    return [2 /*return*/, ledgerEthClient];\n            }\n        });\n    });\n}\nexports.ledgerEthereumBrowserClientFactoryAsync = ledgerEthereumBrowserClientFactoryAsync;\nvar subprovider_utils_1 = require(\"./utils/subprovider_utils\");\nexports.prependSubprovider = subprovider_utils_1.prependSubprovider;\nvar empty_wallet_subprovider_1 = require(\"./subproviders/empty_wallet_subprovider\");\nexports.EmptyWalletSubprovider = empty_wallet_subprovider_1.EmptyWalletSubprovider;\nvar fake_gas_estimate_subprovider_1 = require(\"./subproviders/fake_gas_estimate_subprovider\");\nexports.FakeGasEstimateSubprovider = fake_gas_estimate_subprovider_1.FakeGasEstimateSubprovider;\nvar signer_1 = require(\"./subproviders/signer\");\nexports.SignerSubprovider = signer_1.SignerSubprovider;\nvar redundant_subprovider_1 = require(\"./subproviders/redundant_subprovider\");\nexports.RedundantSubprovider = redundant_subprovider_1.RedundantSubprovider;\nvar ledger_1 = require(\"./subproviders/ledger\");\nexports.LedgerSubprovider = ledger_1.LedgerSubprovider;\nvar rpc_subprovider_1 = require(\"./subproviders/rpc_subprovider\");\nexports.RPCSubprovider = rpc_subprovider_1.RPCSubprovider;\nvar ganache_1 = require(\"./subproviders/ganache\");\nexports.GanacheSubprovider = ganache_1.GanacheSubprovider;\nvar subprovider_1 = require(\"./subproviders/subprovider\");\nexports.Subprovider = subprovider_1.Subprovider;\nvar nonce_tracker_1 = require(\"./subproviders/nonce_tracker\");\nexports.NonceTrackerSubprovider = nonce_tracker_1.NonceTrackerSubprovider;\nvar private_key_wallet_1 = require(\"./subproviders/private_key_wallet\");\nexports.PrivateKeyWalletSubprovider = private_key_wallet_1.PrivateKeyWalletSubprovider;\nvar mnemonic_wallet_1 = require(\"./subproviders/mnemonic_wallet\");\nexports.MnemonicWalletSubprovider = mnemonic_wallet_1.MnemonicWalletSubprovider;\nvar metamask_subprovider_1 = require(\"./subproviders/metamask_subprovider\");\nexports.MetamaskSubprovider = metamask_subprovider_1.MetamaskSubprovider;\nvar trezor_1 = require(\"./subproviders/trezor\");\nexports.TrezorSubprovider = trezor_1.TrezorSubprovider;\nvar types_1 = require(\"./types\");\nexports.NonceSubproviderErrors = types_1.NonceSubproviderErrors;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Prepends a subprovider to a provider\n * @param provider    Given provider\n * @param subprovider Subprovider to prepend\n */\nfunction prependSubprovider(provider, subprovider) {\n    subprovider.setEngine(provider);\n    // HACK: We use implementation details of provider engine here\n    // https://github.com/MetaMask/provider-engine/blob/master/index.js#L68\n    provider._providers = __spread([subprovider], provider._providers);\n}\nexports.prependSubprovider = prependSubprovider;\n//# sourceMappingURL=subprovider_utils.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar subprovider_1 = require(\"./subprovider\");\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine) subprovider interface.\n * It intercepts the `eth_accounts` JSON RPC requests and never returns any addresses when queried.\n */\nvar EmptyWalletSubprovider = /** @class */ (function (_super) {\n    __extends(EmptyWalletSubprovider, _super);\n    function EmptyWalletSubprovider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method conforms to the web3-provider-engine interface.\n     * It is called internally by the ProviderEngine when it is this subproviders\n     * turn to handle a JSON RPC request.\n     * @param payload JSON RPC payload\n     * @param next Callback to call if this subprovider decides not to handle the request\n     * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n     */\n    // tslint:disable-next-line:prefer-function-over-method async-suffix\n    EmptyWalletSubprovider.prototype.handleRequest = function (payload, next, end) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (payload.method) {\n                    case 'eth_accounts':\n                        end(null, []);\n                        return [2 /*return*/];\n                    default:\n                        next();\n                        return [2 /*return*/];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    return EmptyWalletSubprovider;\n}(subprovider_1.Subprovider));\nexports.EmptyWalletSubprovider = EmptyWalletSubprovider;\n//# sourceMappingURL=empty_wallet_subprovider.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar subprovider_1 = require(\"./subprovider\");\n// HACK: We need this so that our tests don't use testrpc gas estimation which sometimes kills the node.\n// Source: https://github.com/trufflesuite/ganache-cli/issues/417\n// Source: https://github.com/trufflesuite/ganache-cli/issues/437\n// Source: https://github.com/MetaMask/provider-engine/blob/master/subproviders/subprovider.js\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine) subprovider interface.\n * It intercepts the `eth_estimateGas` JSON RPC call and always returns a constant gas amount when queried.\n */\nvar FakeGasEstimateSubprovider = /** @class */ (function (_super) {\n    __extends(FakeGasEstimateSubprovider, _super);\n    /**\n     * Instantiates an instance of the FakeGasEstimateSubprovider\n     * @param constantGasAmount The constant gas amount you want returned\n     */\n    function FakeGasEstimateSubprovider(constantGasAmount) {\n        var _this = _super.call(this) || this;\n        _this._constantGasAmount = constantGasAmount;\n        return _this;\n    }\n    /**\n     * This method conforms to the web3-provider-engine interface.\n     * It is called internally by the ProviderEngine when it is this subproviders\n     * turn to handle a JSON RPC request.\n     * @param payload JSON RPC payload\n     * @param next Callback to call if this subprovider decides not to handle the request\n     * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n     */\n    // tslint:disable-next-line:prefer-function-over-method async-suffix\n    FakeGasEstimateSubprovider.prototype.handleRequest = function (payload, next, end) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (payload.method) {\n                    case 'eth_estimateGas':\n                        end(null, this._constantGasAmount);\n                        return [2 /*return*/];\n                    default:\n                        next();\n                        return [2 /*return*/];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    return FakeGasEstimateSubprovider;\n}(subprovider_1.Subprovider));\nexports.FakeGasEstimateSubprovider = FakeGasEstimateSubprovider;\n//# sourceMappingURL=fake_gas_estimate_subprovider.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar web3_wrapper_1 = require(\"@0x/web3-wrapper\");\nvar subprovider_1 = require(\"./subprovider\");\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine)\n * subprovider interface. It forwards JSON RPC requests involving the domain of a signer (getAccounts,\n * sendTransaction, signMessage etc...) to the provider instance supplied at instantiation. All other requests\n * are passed onwards for subsequent subproviders to handle.\n */\nvar SignerSubprovider = /** @class */ (function (_super) {\n    __extends(SignerSubprovider, _super);\n    /**\n     * Instantiates a new SignerSubprovider.\n     * @param supportedProvider Web3 provider that should handle  all user account related requests\n     */\n    function SignerSubprovider(supportedProvider) {\n        var _this = _super.call(this) || this;\n        _this._web3Wrapper = new web3_wrapper_1.Web3Wrapper(supportedProvider);\n        return _this;\n    }\n    /**\n     * This method conforms to the web3-provider-engine interface.\n     * It is called internally by the ProviderEngine when it is this subproviders\n     * turn to handle a JSON RPC request.\n     * @param payload JSON RPC payload\n     * @param next Callback to call if this subprovider decides not to handle the request\n     * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n     */\n    // tslint:disable-next-line:prefer-function-over-method async-suffix\n    SignerSubprovider.prototype.handleRequest = function (payload, next, end) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, message, address, _c, nodeVersion, err_1, accounts, err_2, _d, txParams, txData, txHash, err_3, signature, err_4, signature, err_5;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        _c = payload.method;\n                        switch (_c) {\n                            case 'web3_clientVersion': return [3 /*break*/, 1];\n                            case 'eth_accounts': return [3 /*break*/, 5];\n                            case 'eth_sendTransaction': return [3 /*break*/, 9];\n                            case 'eth_sign': return [3 /*break*/, 14];\n                            case 'eth_signTypedData': return [3 /*break*/, 19];\n                        }\n                        return [3 /*break*/, 24];\n                    case 1:\n                        _e.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._web3Wrapper.getNodeVersionAsync()];\n                    case 2:\n                        nodeVersion = _e.sent();\n                        end(null, nodeVersion);\n                        return [3 /*break*/, 4];\n                    case 3:\n                        err_1 = _e.sent();\n                        end(err_1);\n                        return [3 /*break*/, 4];\n                    case 4: return [2 /*return*/];\n                    case 5:\n                        _e.trys.push([5, 7, , 8]);\n                        return [4 /*yield*/, this._web3Wrapper.getAvailableAddressesAsync()];\n                    case 6:\n                        accounts = _e.sent();\n                        end(null, accounts);\n                        return [3 /*break*/, 8];\n                    case 7:\n                        err_2 = _e.sent();\n                        end(err_2);\n                        return [3 /*break*/, 8];\n                    case 8: return [2 /*return*/];\n                    case 9:\n                        _d = __read(payload.params, 1), txParams = _d[0];\n                        _e.label = 10;\n                    case 10:\n                        _e.trys.push([10, 12, , 13]);\n                        txData = web3_wrapper_1.marshaller.unmarshalTxData(txParams);\n                        return [4 /*yield*/, this._web3Wrapper.sendTransactionAsync(txData)];\n                    case 11:\n                        txHash = _e.sent();\n                        end(null, txHash);\n                        return [3 /*break*/, 13];\n                    case 12:\n                        err_3 = _e.sent();\n                        end(err_3);\n                        return [3 /*break*/, 13];\n                    case 13: return [2 /*return*/];\n                    case 14:\n                        _a = __read(payload.params, 2), address = _a[0], message = _a[1];\n                        _e.label = 15;\n                    case 15:\n                        _e.trys.push([15, 17, , 18]);\n                        return [4 /*yield*/, this._web3Wrapper.signMessageAsync(address, message)];\n                    case 16:\n                        signature = _e.sent();\n                        end(null, signature);\n                        return [3 /*break*/, 18];\n                    case 17:\n                        err_4 = _e.sent();\n                        end(err_4);\n                        return [3 /*break*/, 18];\n                    case 18: return [2 /*return*/];\n                    case 19:\n                        _b = __read(payload.params, 2), address = _b[0], message = _b[1];\n                        _e.label = 20;\n                    case 20:\n                        _e.trys.push([20, 22, , 23]);\n                        return [4 /*yield*/, this._web3Wrapper.signTypedDataAsync(address, message)];\n                    case 21:\n                        signature = _e.sent();\n                        end(null, signature);\n                        return [3 /*break*/, 23];\n                    case 22:\n                        err_5 = _e.sent();\n                        end(err_5);\n                        return [3 /*break*/, 23];\n                    case 23: return [2 /*return*/];\n                    case 24:\n                        next();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return SignerSubprovider;\n}(subprovider_1.Subprovider));\nexports.SignerSubprovider = SignerSubprovider;\n//# sourceMappingURL=signer.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"@0x/utils\");\nvar subprovider_1 = require(\"./subprovider\");\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine) subprovider interface.\n * It attempts to handle each JSON RPC request by sequentially attempting to receive a valid response from one of a\n * set of JSON RPC endpoints.\n */\nvar RedundantSubprovider = /** @class */ (function (_super) {\n    __extends(RedundantSubprovider, _super);\n    /**\n     * Instantiates a new RedundantSubprovider\n     * @param subproviders Subproviders to attempt the request with\n     */\n    function RedundantSubprovider(subproviders) {\n        var _this = _super.call(this) || this;\n        _this._subproviders = subproviders;\n        return _this;\n    }\n    RedundantSubprovider._firstSuccessAsync = function (subproviders, payload, next) {\n        return __awaiter(this, void 0, void 0, function () {\n            var e_1, _a, lastErr, subproviders_1, subproviders_1_1, subprovider, data, err_1, e_1_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 7, 8, 9]);\n                        subproviders_1 = __values(subproviders), subproviders_1_1 = subproviders_1.next();\n                        _b.label = 1;\n                    case 1:\n                        if (!!subproviders_1_1.done) return [3 /*break*/, 6];\n                        subprovider = subproviders_1_1.value;\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, utils_1.promisify(subprovider.handleRequest.bind(subprovider))(payload, next)];\n                    case 3:\n                        data = _b.sent();\n                        return [2 /*return*/, data];\n                    case 4:\n                        err_1 = _b.sent();\n                        lastErr = err_1;\n                        return [3 /*break*/, 5];\n                    case 5:\n                        subproviders_1_1 = subproviders_1.next();\n                        return [3 /*break*/, 1];\n                    case 6: return [3 /*break*/, 9];\n                    case 7:\n                        e_1_1 = _b.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 9];\n                    case 8:\n                        try {\n                            if (subproviders_1_1 && !subproviders_1_1.done && (_a = subproviders_1.return)) _a.call(subproviders_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                        return [7 /*endfinally*/];\n                    case 9:\n                        if (lastErr !== undefined) {\n                            throw lastErr;\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This method conforms to the web3-provider-engine interface.\n     * It is called internally by the ProviderEngine when it is this subproviders\n     * turn to handle a JSON RPC request.\n     * @param payload JSON RPC payload\n     * @param next Callback to call if this subprovider decides not to handle the request\n     * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n     */\n    // tslint:disable-next-line:async-suffix\n    RedundantSubprovider.prototype.handleRequest = function (payload, next, end) {\n        return __awaiter(this, void 0, void 0, function () {\n            var subprovidersCopy, data, err_2;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        subprovidersCopy = this._subproviders.slice();\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, RedundantSubprovider._firstSuccessAsync(subprovidersCopy, payload, next)];\n                    case 2:\n                        data = _a.sent();\n                        end(null, data);\n                        return [3 /*break*/, 4];\n                    case 3:\n                        err_2 = _a.sent();\n                        end(err_2);\n                        return [3 /*break*/, 4];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return RedundantSubprovider;\n}(subprovider_1.Subprovider));\nexports.RedundantSubprovider = RedundantSubprovider;\n//# sourceMappingURL=redundant_subprovider.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Ganache = require(\"ganache-core\");\nvar subprovider_1 = require(\"./subprovider\");\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine) subprovider interface.\n * It intercepts all JSON RPC requests and relays them to an in-process ganache instance.\n */\nvar GanacheSubprovider = /** @class */ (function (_super) {\n    __extends(GanacheSubprovider, _super);\n    /**\n     * Instantiates a GanacheSubprovider\n     * @param opts The desired opts with which to instantiate the Ganache provider\n     */\n    function GanacheSubprovider(opts) {\n        var _this = _super.call(this) || this;\n        _this._ganacheProvider = Ganache.provider(opts);\n        return _this;\n    }\n    /**\n     * This method conforms to the web3-provider-engine interface.\n     * It is called internally by the ProviderEngine when it is this subproviders\n     * turn to handle a JSON RPC request.\n     * @param payload JSON RPC payload\n     * @param _next Callback to call if this subprovider decides not to handle the request\n     * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n     */\n    // tslint:disable-next-line:prefer-function-over-method async-suffix\n    GanacheSubprovider.prototype.handleRequest = function (payload, _next, end) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                this._ganacheProvider.sendAsync(payload, function (err, result) {\n                    end(err, result && result.result);\n                });\n                return [2 /*return*/];\n            });\n        });\n    };\n    return GanacheSubprovider;\n}(subprovider_1.Subprovider));\nexports.GanacheSubprovider = GanacheSubprovider;\n//# sourceMappingURL=ganache.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ = require(\"lodash\");\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar EthereumTx = require(\"ethereumjs-tx\");\nvar ethUtil = require(\"ethereumjs-util\");\nvar providerEngineUtils = require(\"web3-provider-engine/util/rpc-cache-utils\");\nvar types_1 = require(\"../types\");\nvar subprovider_1 = require(\"./subprovider\");\nvar NONCE_TOO_LOW_ERROR_MESSAGE = 'Transaction nonce is too low';\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine) subprovider interface.\n * It is heavily inspired by the [NonceSubprovider](https://github.com/MetaMask/provider-engine/blob/master/subproviders/nonce-tracker.js).\n * We added the additional feature of clearing the cached nonce value when a `nonce value too low` error occurs.\n */\nvar NonceTrackerSubprovider = /** @class */ (function (_super) {\n    __extends(NonceTrackerSubprovider, _super);\n    function NonceTrackerSubprovider() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._nonceCache = {};\n        return _this;\n    }\n    NonceTrackerSubprovider._reconstructTransaction = function (payload) {\n        var raw = payload.params[0];\n        if (raw === undefined) {\n            throw new Error(types_1.NonceSubproviderErrors.EmptyParametersFound);\n        }\n        var rawData = ethUtil.toBuffer(raw);\n        var transaction = new EthereumTx(rawData);\n        return transaction;\n    };\n    NonceTrackerSubprovider._determineAddress = function (payload) {\n        var address;\n        switch (payload.method) {\n            case 'eth_getTransactionCount':\n                address = payload.params[0].toLowerCase();\n                return address;\n            case 'eth_sendRawTransaction':\n                var transaction = NonceTrackerSubprovider._reconstructTransaction(payload);\n                var addressRaw = transaction\n                    .getSenderAddress()\n                    .toString('hex')\n                    .toLowerCase();\n                address = \"0x\" + addressRaw;\n                return address;\n            default:\n                throw new Error(types_1.NonceSubproviderErrors.CannotDetermineAddressFromPayload);\n        }\n    };\n    /**\n     * This method conforms to the web3-provider-engine interface.\n     * It is called internally by the ProviderEngine when it is this subproviders\n     * turn to handle a JSON RPC request.\n     * @param payload JSON RPC payload\n     * @param next Callback to call if this subprovider decides not to handle the request\n     * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n     */\n    // tslint:disable-next-line:async-suffix\n    NonceTrackerSubprovider.prototype.handleRequest = function (payload, next, end) {\n        return __awaiter(this, void 0, void 0, function () {\n            var requestDefaultBlock, address_1, cachedResult;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (payload.method) {\n                    case 'eth_getTransactionCount':\n                        requestDefaultBlock = providerEngineUtils.blockTagForPayload(payload);\n                        if (requestDefaultBlock === ethereum_types_1.BlockParamLiteral.Pending) {\n                            address_1 = NonceTrackerSubprovider._determineAddress(payload);\n                            cachedResult = this._nonceCache[address_1];\n                            if (cachedResult !== undefined) {\n                                return [2 /*return*/, end(null, cachedResult)];\n                            }\n                            else {\n                                return [2 /*return*/, next(function (requestError, requestResult, cb) {\n                                        if (requestError === null) {\n                                            _this._nonceCache[address_1] = requestResult;\n                                        }\n                                        cb();\n                                    })];\n                            }\n                        }\n                        else {\n                            return [2 /*return*/, next()];\n                        }\n                    case 'eth_sendRawTransaction':\n                        return [2 /*return*/, next(function (sendTransactionError, _txResult, cb) {\n                                if (sendTransactionError === null) {\n                                    _this._handleSuccessfulTransaction(payload);\n                                }\n                                else {\n                                    _this._handleSendTransactionError(payload, sendTransactionError);\n                                }\n                                cb();\n                            })];\n                    default:\n                        return [2 /*return*/, next()];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    NonceTrackerSubprovider.prototype._handleSuccessfulTransaction = function (payload) {\n        var address = NonceTrackerSubprovider._determineAddress(payload);\n        var transaction = NonceTrackerSubprovider._reconstructTransaction(payload);\n        // Increment the nonce from the previous successfully submitted transaction\n        var nonce = ethUtil.bufferToInt(transaction.nonce);\n        nonce++;\n        var hexBase = 16;\n        var nextHexNonce = nonce.toString(hexBase);\n        if (nextHexNonce.length % 2) {\n            nextHexNonce = \"0\" + nextHexNonce;\n        }\n        var nextPrefixedHexNonce = \"0x\" + nextHexNonce;\n        this._nonceCache[address] = nextPrefixedHexNonce;\n    };\n    NonceTrackerSubprovider.prototype._handleSendTransactionError = function (payload, err) {\n        var address = NonceTrackerSubprovider._determineAddress(payload);\n        if (this._nonceCache[address] && _.includes(err.message, NONCE_TOO_LOW_ERROR_MESSAGE)) {\n            delete this._nonceCache[address];\n        }\n    };\n    return NonceTrackerSubprovider;\n}(subprovider_1.Subprovider));\nexports.NonceTrackerSubprovider = NonceTrackerSubprovider;\n//# sourceMappingURL=nonce_tracker.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"@0x/assert\");\nvar utils_1 = require(\"@0x/utils\");\nvar bip39 = require(\"bip39\");\nvar HDNode = require(\"hdkey\");\nvar _ = require(\"lodash\");\nvar types_1 = require(\"../types\");\nvar wallet_utils_1 = require(\"../utils/wallet_utils\");\nvar base_wallet_subprovider_1 = require(\"./base_wallet_subprovider\");\nvar private_key_wallet_1 = require(\"./private_key_wallet\");\nvar DEFAULT_BASE_DERIVATION_PATH = \"44'/60'/0'/0\";\nvar DEFAULT_NUM_ADDRESSES_TO_FETCH = 10;\nvar DEFAULT_ADDRESS_SEARCH_LIMIT = 1000;\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine) subprovider interface.\n * This subprovider intercepts all account related RPC requests (e.g message/transaction signing, etc...) and handles\n * all requests with accounts derived from the supplied mnemonic.\n */\nvar MnemonicWalletSubprovider = /** @class */ (function (_super) {\n    __extends(MnemonicWalletSubprovider, _super);\n    /**\n     * Instantiates a MnemonicWalletSubprovider. Defaults to baseDerivationPath set to `44'/60'/0'/0`.\n     * This is the default in TestRPC/Ganache, it can be overridden if desired.\n     * @param config Configuration for the mnemonic wallet, must contain the mnemonic\n     * @return MnemonicWalletSubprovider instance\n     */\n    function MnemonicWalletSubprovider(config) {\n        var _this = this;\n        assert_1.assert.isString('mnemonic', config.mnemonic);\n        var baseDerivationPath = config.baseDerivationPath || DEFAULT_BASE_DERIVATION_PATH;\n        assert_1.assert.isString('baseDerivationPath', baseDerivationPath);\n        var addressSearchLimit = config.addressSearchLimit || DEFAULT_ADDRESS_SEARCH_LIMIT;\n        assert_1.assert.isNumber('addressSearchLimit', addressSearchLimit);\n        _this = _super.call(this) || this;\n        _this._mnemonic = config.mnemonic;\n        _this._baseDerivationPath = baseDerivationPath;\n        _this._addressSearchLimit = addressSearchLimit;\n        _this._derivedKeyInfo = _this._initialDerivedKeyInfo(_this._baseDerivationPath);\n        return _this;\n    }\n    /**\n     * Retrieve the set derivation path\n     * @returns derivation path\n     */\n    MnemonicWalletSubprovider.prototype.getPath = function () {\n        return this._baseDerivationPath;\n    };\n    /**\n     * Set a desired derivation path when computing the available user addresses\n     * @param baseDerivationPath The desired derivation path (e.g `44'/60'/0'`)\n     */\n    MnemonicWalletSubprovider.prototype.setPath = function (baseDerivationPath) {\n        this._baseDerivationPath = baseDerivationPath;\n        this._derivedKeyInfo = this._initialDerivedKeyInfo(this._baseDerivationPath);\n    };\n    /**\n     * Retrieve the accounts associated with the mnemonic.\n     * This method is implicitly called when issuing a `eth_accounts` JSON RPC request\n     * via your providerEngine instance.\n     * @param numberOfAccounts Number of accounts to retrieve (default: 10)\n     * @return An array of accounts\n     */\n    MnemonicWalletSubprovider.prototype.getAccountsAsync = function (numberOfAccounts) {\n        if (numberOfAccounts === void 0) { numberOfAccounts = DEFAULT_NUM_ADDRESSES_TO_FETCH; }\n        return __awaiter(this, void 0, void 0, function () {\n            var derivedKeys, accounts;\n            return __generator(this, function (_a) {\n                derivedKeys = wallet_utils_1.walletUtils.calculateDerivedHDKeyInfos(this._derivedKeyInfo, numberOfAccounts);\n                accounts = _.map(derivedKeys, function (k) { return k.address; });\n                return [2 /*return*/, accounts];\n            });\n        });\n    };\n    /**\n     * Signs a transaction with the account specificed by the `from` field in txParams.\n     * If you've added this Subprovider to your  app's provider, you can simply send\n     * an `eth_sendTransaction` JSON RPC request, and this method will be called auto-magically.\n     * If you are not using this via a ProviderEngine instance, you can call it directly.\n     * @param txParams Parameters of the transaction to sign\n     * @return Signed transaction hex string\n     */\n    MnemonicWalletSubprovider.prototype.signTransactionAsync = function (txParams) {\n        return __awaiter(this, void 0, void 0, function () {\n            var privateKeyWallet, signedTx;\n            return __generator(this, function (_a) {\n                if (txParams.from === undefined || !utils_1.addressUtils.isAddress(txParams.from)) {\n                    throw new Error(types_1.WalletSubproviderErrors.FromAddressMissingOrInvalid);\n                }\n                privateKeyWallet = this._privateKeyWalletForAddress(txParams.from);\n                signedTx = privateKeyWallet.signTransactionAsync(txParams);\n                return [2 /*return*/, signedTx];\n            });\n        });\n    };\n    /**\n     * Sign a personal Ethereum signed message. The signing account will be the account\n     * associated with the provided address. If you've added the MnemonicWalletSubprovider to\n     * your app's provider, you can simply send an `eth_sign` or `personal_sign` JSON RPC request,\n     * and this method will be called auto-magically. If you are not using this via a ProviderEngine\n     * instance, you can call it directly.\n     * @param data Hex string message to sign\n     * @param address Address of the account to sign with\n     * @return Signature hex string (order: rsv)\n     */\n    MnemonicWalletSubprovider.prototype.signPersonalMessageAsync = function (data, address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var privateKeyWallet, sig;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (data === undefined) {\n                            throw new Error(types_1.WalletSubproviderErrors.DataMissingForSignPersonalMessage);\n                        }\n                        assert_1.assert.isHexString('data', data);\n                        assert_1.assert.isETHAddressHex('address', address);\n                        privateKeyWallet = this._privateKeyWalletForAddress(address);\n                        return [4 /*yield*/, privateKeyWallet.signPersonalMessageAsync(data, address)];\n                    case 1:\n                        sig = _a.sent();\n                        return [2 /*return*/, sig];\n                }\n            });\n        });\n    };\n    /**\n     * Sign an EIP712 Typed Data message. The signing account will be the account\n     * associated with the provided address. If you've added this MnemonicWalletSubprovider to\n     * your app's provider, you can simply send an `eth_signTypedData` JSON RPC request, and\n     * this method will be called auto-magically. If you are not using this via a ProviderEngine\n     *  instance, you can call it directly.\n     * @param address Address of the account to sign with\n     * @param data the typed data object\n     * @return Signature hex string (order: rsv)\n     */\n    MnemonicWalletSubprovider.prototype.signTypedDataAsync = function (address, typedData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var privateKeyWallet, sig;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (typedData === undefined) {\n                            throw new Error(types_1.WalletSubproviderErrors.DataMissingForSignPersonalMessage);\n                        }\n                        assert_1.assert.isETHAddressHex('address', address);\n                        privateKeyWallet = this._privateKeyWalletForAddress(address);\n                        return [4 /*yield*/, privateKeyWallet.signTypedDataAsync(address, typedData)];\n                    case 1:\n                        sig = _a.sent();\n                        return [2 /*return*/, sig];\n                }\n            });\n        });\n    };\n    MnemonicWalletSubprovider.prototype._privateKeyWalletForAddress = function (address) {\n        var derivedKeyInfo = this._findDerivedKeyInfoForAddress(address);\n        var privateKeyHex = derivedKeyInfo.hdKey.privateKey.toString('hex');\n        var privateKeyWallet = new private_key_wallet_1.PrivateKeyWalletSubprovider(privateKeyHex);\n        return privateKeyWallet;\n    };\n    MnemonicWalletSubprovider.prototype._findDerivedKeyInfoForAddress = function (address) {\n        var matchedDerivedKeyInfo = wallet_utils_1.walletUtils.findDerivedKeyInfoForAddressIfExists(address, this._derivedKeyInfo, this._addressSearchLimit);\n        if (matchedDerivedKeyInfo === undefined) {\n            throw new Error(types_1.WalletSubproviderErrors.AddressNotFound + \": \" + address);\n        }\n        return matchedDerivedKeyInfo;\n    };\n    MnemonicWalletSubprovider.prototype._initialDerivedKeyInfo = function (baseDerivationPath) {\n        var seed = bip39.mnemonicToSeed(this._mnemonic);\n        var hdKey = HDNode.fromMasterSeed(seed);\n        // Walk down to base derivation level (i.e m/44'/60'/0') and create an initial key at that level\n        // all children will then be walked relative (i.e m/0)\n        var parentKeyDerivationPath = \"m/\" + baseDerivationPath;\n        var parentHDKeyAtDerivationPath = hdKey.derive(parentKeyDerivationPath);\n        var address = wallet_utils_1.walletUtils.addressOfHDKey(parentHDKeyAtDerivationPath);\n        var derivedKeyInfo = {\n            address: address,\n            baseDerivationPath: baseDerivationPath,\n            derivationPath: parentKeyDerivationPath,\n            hdKey: parentHDKeyAtDerivationPath,\n        };\n        return derivedKeyInfo;\n    };\n    return MnemonicWalletSubprovider;\n}(base_wallet_subprovider_1.BaseWalletSubprovider));\nexports.MnemonicWalletSubprovider = MnemonicWalletSubprovider;\n//# sourceMappingURL=mnemonic_wallet.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"@0x/utils\");\nvar web3_wrapper_1 = require(\"@0x/web3-wrapper\");\nvar subprovider_1 = require(\"./subprovider\");\n/**\n * This class implements the [web3-provider-engine](https://github.com/MetaMask/provider-engine)\n * subprovider interface and the provider sendAsync interface.\n * It handles inconsistencies with Metamask implementations of various JSON RPC methods.\n * It forwards JSON RPC requests involving the domain of a signer (getAccounts,\n * sendTransaction, signMessage etc...) to the provider instance supplied at instantiation. All other requests\n * are passed onwards for subsequent subproviders to handle.\n */\nvar MetamaskSubprovider = /** @class */ (function (_super) {\n    __extends(MetamaskSubprovider, _super);\n    /**\n     * Instantiates a new MetamaskSubprovider\n     * @param supportedProvider Web3 provider that should handle  all user account related requests\n     */\n    function MetamaskSubprovider(supportedProvider) {\n        var _this = _super.call(this) || this;\n        var provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n        _this._web3Wrapper = new web3_wrapper_1.Web3Wrapper(provider);\n        _this._provider = provider;\n        return _this;\n    }\n    /**\n     * This method conforms to the web3-provider-engine interface.\n     * It is called internally by the ProviderEngine when it is this subproviders\n     * turn to handle a JSON RPC request.\n     * @param payload JSON RPC payload\n     * @param next Callback to call if this subprovider decides not to handle the request\n     * @param end Callback to call if subprovider handled the request and wants to pass back the request.\n     */\n    // tslint:disable-next-line:prefer-function-over-method async-suffix\n    MetamaskSubprovider.prototype.handleRequest = function (payload, next, end) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, message, address, _c, nodeVersion, err_1, accounts, err_2, _d, txParams, txData, txHash, err_3, signature, err_4, messageJSON, signature, err_5;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        _c = payload.method;\n                        switch (_c) {\n                            case 'web3_clientVersion': return [3 /*break*/, 1];\n                            case 'eth_accounts': return [3 /*break*/, 5];\n                            case 'eth_sendTransaction': return [3 /*break*/, 9];\n                            case 'eth_sign': return [3 /*break*/, 14];\n                            case 'eth_signTypedData': return [3 /*break*/, 19];\n                            case 'eth_signTypedData_v3': return [3 /*break*/, 19];\n                        }\n                        return [3 /*break*/, 24];\n                    case 1:\n                        _e.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._web3Wrapper.getNodeVersionAsync()];\n                    case 2:\n                        nodeVersion = _e.sent();\n                        end(null, nodeVersion);\n                        return [3 /*break*/, 4];\n                    case 3:\n                        err_1 = _e.sent();\n                        end(err_1);\n                        return [3 /*break*/, 4];\n                    case 4: return [2 /*return*/];\n                    case 5:\n                        _e.trys.push([5, 7, , 8]);\n                        return [4 /*yield*/, this._web3Wrapper.getAvailableAddressesAsync()];\n                    case 6:\n                        accounts = _e.sent();\n                        end(null, accounts);\n                        return [3 /*break*/, 8];\n                    case 7:\n                        err_2 = _e.sent();\n                        end(err_2);\n                        return [3 /*break*/, 8];\n                    case 8: return [2 /*return*/];\n                    case 9:\n                        _d = __read(payload.params, 1), txParams = _d[0];\n                        _e.label = 10;\n                    case 10:\n                        _e.trys.push([10, 12, , 13]);\n                        txData = web3_wrapper_1.marshaller.unmarshalTxData(txParams);\n                        return [4 /*yield*/, this._web3Wrapper.sendTransactionAsync(txData)];\n                    case 11:\n                        txHash = _e.sent();\n                        end(null, txHash);\n                        return [3 /*break*/, 13];\n                    case 12:\n                        err_3 = _e.sent();\n                        end(err_3);\n                        return [3 /*break*/, 13];\n                    case 13: return [2 /*return*/];\n                    case 14:\n                        _a = __read(payload.params, 2), address = _a[0], message = _a[1];\n                        _e.label = 15;\n                    case 15:\n                        _e.trys.push([15, 17, , 18]);\n                        return [4 /*yield*/, this._web3Wrapper.sendRawPayloadAsync({\n                                method: 'personal_sign',\n                                params: [message, address],\n                            })];\n                    case 16:\n                        signature = _e.sent();\n                        signature ? end(null, signature) : end(new Error('Error performing eth_sign'), null);\n                        return [3 /*break*/, 18];\n                    case 17:\n                        err_4 = _e.sent();\n                        end(err_4);\n                        return [3 /*break*/, 18];\n                    case 18: return [2 /*return*/];\n                    case 19:\n                        _b = __read(payload.params, 2), address = _b[0], message = _b[1];\n                        _e.label = 20;\n                    case 20:\n                        _e.trys.push([20, 22, , 23]);\n                        messageJSON = JSON.stringify(message);\n                        return [4 /*yield*/, this._web3Wrapper.sendRawPayloadAsync({\n                                method: 'eth_signTypedData_v3',\n                                params: [address, messageJSON],\n                            })];\n                    case 21:\n                        signature = _e.sent();\n                        signature ? end(null, signature) : end(new Error('Error performing eth_signTypedData'), null);\n                        return [3 /*break*/, 23];\n                    case 22:\n                        err_5 = _e.sent();\n                        end(err_5);\n                        return [3 /*break*/, 23];\n                    case 23: return [2 /*return*/];\n                    case 24:\n                        next();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This method conforms to the provider sendAsync interface.\n     * Allowing the MetamaskSubprovider to be used as a generic provider (outside of Web3ProviderEngine) with the\n     * addition of wrapping the inconsistent Metamask behaviour\n     * @param payload JSON RPC payload\n     * @return The contents nested under the result key of the response body\n     */\n    MetamaskSubprovider.prototype.sendAsync = function (payload, callback) {\n        var _this = this;\n        void this.handleRequest(payload, \n        // handleRequest has decided to not handle this, so fall through to the provider\n        function () {\n            var sendAsync = _this._provider.sendAsync.bind(_this._provider);\n            sendAsync(payload, callback);\n        }, \n        // handleRequest has called end and will handle this\n        function (err, data) {\n            err ? callback(err) : callback(null, __assign({}, payload, { result: data }));\n        });\n    };\n    return MetamaskSubprovider;\n}(subprovider_1.Subprovider));\nexports.MetamaskSubprovider = MetamaskSubprovider;\n//# sourceMappingURL=metamask_subprovider.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"@0x/assert\");\nvar utils_1 = require(\"@0x/utils\");\nvar EthereumTx = require(\"ethereumjs-tx\");\nvar _ = require(\"lodash\");\nvar HDNode = require(\"hdkey\");\nvar types_1 = require(\"../types\");\nvar wallet_utils_1 = require(\"../utils/wallet_utils\");\nvar base_wallet_subprovider_1 = require(\"./base_wallet_subprovider\");\nvar PRIVATE_KEY_PATH = \"44'/60'/0'/0\";\nvar DEFAULT_NUM_ADDRESSES_TO_FETCH = 10;\nvar DEFAULT_ADDRESS_SEARCH_LIMIT = 1000;\nvar TrezorSubprovider = /** @class */ (function (_super) {\n    __extends(TrezorSubprovider, _super);\n    /**\n     * Instantiates a TrezorSubprovider. Defaults to private key path set to `44'/60'/0'/0/`.\n     * Must be initialized with trezor-connect API module https://github.com/trezor/connect.\n     * @param TrezorSubprovider config object containing trezor-connect API\n     * @return TrezorSubprovider instance\n     */\n    function TrezorSubprovider(config) {\n        var _this = _super.call(this) || this;\n        _this._privateKeyPath = PRIVATE_KEY_PATH;\n        _this._trezorConnectClientApi = config.trezorConnectClientApi;\n        _this._networkId = config.networkId;\n        _this._addressSearchLimit =\n            config.accountFetchingConfigs !== undefined &&\n                config.accountFetchingConfigs.addressSearchLimit !== undefined\n                ? config.accountFetchingConfigs.addressSearchLimit\n                : DEFAULT_ADDRESS_SEARCH_LIMIT;\n        return _this;\n    }\n    /**\n     * Retrieve a users Trezor account. This method is automatically called\n     * when issuing a `eth_accounts` JSON RPC request via your providerEngine\n     * instance.\n     * @return An array of accounts\n     */\n    TrezorSubprovider.prototype.getAccountsAsync = function (numberOfAccounts) {\n        if (numberOfAccounts === void 0) { numberOfAccounts = DEFAULT_NUM_ADDRESSES_TO_FETCH; }\n        return __awaiter(this, void 0, void 0, function () {\n            var initialDerivedKeyInfo, derivedKeyInfos, accounts;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._initialDerivedKeyInfoAsync()];\n                    case 1:\n                        initialDerivedKeyInfo = _a.sent();\n                        derivedKeyInfos = wallet_utils_1.walletUtils.calculateDerivedHDKeyInfos(initialDerivedKeyInfo, numberOfAccounts);\n                        accounts = _.map(derivedKeyInfos, function (k) { return k.address; });\n                        return [2 /*return*/, accounts];\n                }\n            });\n        });\n    };\n    /**\n     * Signs a transaction on the Trezor with the account specificed by the `from` field in txParams.\n     * If you've added the TrezorSubprovider to your app's provider, you can simply send an `eth_sendTransaction`\n     * JSON RPC request, and this method will be called auto-magically. If you are not using this via a ProviderEngine\n     * instance, you can call it directly.\n     * @param txParams Parameters of the transaction to sign\n     * @return Signed transaction hex string\n     */\n    TrezorSubprovider.prototype.signTransactionAsync = function (txData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var initialDerivedKeyInfo, derivedKeyInfo, fullDerivationPath, response, payload, tx, vIndex, rIndex, sIndex, payload;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (txData.from === undefined || !utils_1.addressUtils.isAddress(txData.from)) {\n                            throw new Error(types_1.WalletSubproviderErrors.FromAddressMissingOrInvalid);\n                        }\n                        txData.value = txData.value ? txData.value : '0x0';\n                        txData.data = txData.data ? txData.data : '0x';\n                        txData.gas = txData.gas ? txData.gas : '0x0';\n                        txData.gasPrice = txData.gasPrice ? txData.gasPrice : '0x0';\n                        return [4 /*yield*/, this._initialDerivedKeyInfoAsync()];\n                    case 1:\n                        initialDerivedKeyInfo = _a.sent();\n                        derivedKeyInfo = this._findDerivedKeyInfoForAddress(initialDerivedKeyInfo, txData.from);\n                        fullDerivationPath = derivedKeyInfo.derivationPath;\n                        return [4 /*yield*/, this._trezorConnectClientApi.ethereumSignTransaction({\n                                path: fullDerivationPath,\n                                transaction: {\n                                    to: txData.to,\n                                    value: txData.value,\n                                    data: txData.data,\n                                    chainId: this._networkId,\n                                    nonce: txData.nonce,\n                                    gasLimit: txData.gas,\n                                    gasPrice: txData.gasPrice,\n                                },\n                            })];\n                    case 2:\n                        response = _a.sent();\n                        if (response.success) {\n                            payload = response.payload;\n                            tx = new EthereumTx(txData);\n                            vIndex = 6;\n                            tx.raw[vIndex] = Buffer.from([1]); // v\n                            rIndex = 7;\n                            tx.raw[rIndex] = Buffer.from([]); // r\n                            sIndex = 8;\n                            tx.raw[sIndex] = Buffer.from([]); // s\n                            // slice off leading 0x\n                            tx.v = Buffer.from(payload.v.slice(2), 'hex');\n                            tx.r = Buffer.from(payload.r.slice(2), 'hex');\n                            tx.s = Buffer.from(payload.s.slice(2), 'hex');\n                            return [2 /*return*/, \"0x\" + tx.serialize().toString('hex')];\n                        }\n                        else {\n                            payload = response.payload;\n                            throw new Error(payload.error);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Sign a personal Ethereum signed message. The signing account will be the account\n     * associated with the provided address. If you've added the TrezorSubprovider to\n     * your app's provider, you can simply send an `eth_sign` or `personal_sign` JSON RPC\n     * request, and this method will be called auto-magically.\n     * If you are not using this via a ProviderEngine instance, you can call it directly.\n     * @param data Hex string message to sign\n     * @param address Address of the account to sign with\n     * @return Signature hex string (order: rsv)\n     */\n    TrezorSubprovider.prototype.signPersonalMessageAsync = function (data, address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var initialDerivedKeyInfo, derivedKeyInfo, fullDerivationPath, response, payload, payload;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (data === undefined) {\n                            throw new Error(types_1.WalletSubproviderErrors.DataMissingForSignPersonalMessage);\n                        }\n                        assert_1.assert.isHexString('data', data);\n                        assert_1.assert.isETHAddressHex('address', address);\n                        return [4 /*yield*/, this._initialDerivedKeyInfoAsync()];\n                    case 1:\n                        initialDerivedKeyInfo = _a.sent();\n                        derivedKeyInfo = this._findDerivedKeyInfoForAddress(initialDerivedKeyInfo, address);\n                        fullDerivationPath = derivedKeyInfo.derivationPath;\n                        return [4 /*yield*/, this._trezorConnectClientApi.ethereumSignMessage({\n                                path: fullDerivationPath,\n                                message: data,\n                                hex: true,\n                            })];\n                    case 2:\n                        response = _a.sent();\n                        if (response.success) {\n                            payload = response.payload;\n                            return [2 /*return*/, \"0x\" + payload.signature];\n                        }\n                        else {\n                            payload = response.payload;\n                            throw new Error(payload.error);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * TODO:: eth_signTypedData is currently not supported on Trezor devices.\n     * @param address Address of the account to sign with\n     * @param data the typed data object\n     * @return Signature hex string (order: rsv)\n     */\n    // tslint:disable-next-line:prefer-function-over-method\n    TrezorSubprovider.prototype.signTypedDataAsync = function (address, typedData) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                throw new Error(types_1.WalletSubproviderErrors.MethodNotSupported);\n            });\n        });\n    };\n    TrezorSubprovider.prototype._initialDerivedKeyInfoAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var parentKeyDerivationPath, response, payload, hdKey, address, initialDerivedKeyInfo, payload;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this._initialDerivedKeyInfo) return [3 /*break*/, 1];\n                        return [2 /*return*/, this._initialDerivedKeyInfo];\n                    case 1:\n                        parentKeyDerivationPath = \"m/\" + this._privateKeyPath;\n                        return [4 /*yield*/, this._trezorConnectClientApi.getPublicKey({\n                                path: parentKeyDerivationPath,\n                            })];\n                    case 2:\n                        response = _a.sent();\n                        if (response.success) {\n                            payload = response.payload;\n                            hdKey = new HDNode();\n                            hdKey.publicKey = new Buffer(payload.publicKey, 'hex');\n                            hdKey.chainCode = new Buffer(payload.chainCode, 'hex');\n                            address = wallet_utils_1.walletUtils.addressOfHDKey(hdKey);\n                            initialDerivedKeyInfo = {\n                                hdKey: hdKey,\n                                address: address,\n                                derivationPath: parentKeyDerivationPath,\n                                baseDerivationPath: this._privateKeyPath,\n                            };\n                            this._initialDerivedKeyInfo = initialDerivedKeyInfo;\n                            return [2 /*return*/, initialDerivedKeyInfo];\n                        }\n                        else {\n                            payload = response.payload;\n                            throw new Error(payload.error);\n                        }\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    TrezorSubprovider.prototype._findDerivedKeyInfoForAddress = function (initalHDKey, address) {\n        var matchedDerivedKeyInfo = wallet_utils_1.walletUtils.findDerivedKeyInfoForAddressIfExists(address, initalHDKey, this._addressSearchLimit);\n        if (matchedDerivedKeyInfo === undefined) {\n            throw new Error(types_1.WalletSubproviderErrors.AddressNotFound + \": \" + address);\n        }\n        return matchedDerivedKeyInfo;\n    };\n    return TrezorSubprovider;\n}(base_wallet_subprovider_1.BaseWalletSubprovider));\nexports.TrezorSubprovider = TrezorSubprovider;\n//# sourceMappingURL=trezor.js.map","const inherits = require('util').inherits\nconst ethUtil = require('ethereumjs-util')\nconst BN = ethUtil.BN\nconst clone = require('clone')\nconst cacheUtils = require('../util/rpc-cache-utils.js')\nconst Stoplight = require('../util/stoplight.js')\nconst Subprovider = require('./subprovider.js')\n\nmodule.exports = BlockCacheProvider\n\ninherits(BlockCacheProvider, Subprovider)\n\nfunction BlockCacheProvider(opts) {\n  const self = this\n  opts = opts || {}\n  // set initialization blocker\n  self._ready = new Stoplight()\n  self.strategies = {\n    perma: new ConditionalPermaCacheStrategy({\n      eth_getTransactionByHash: containsBlockhash,\n      eth_getTransactionReceipt: containsBlockhash,\n    }),\n    block: new BlockCacheStrategy(self),\n    fork: new BlockCacheStrategy(self),\n  }\n}\n\n// setup a block listener on 'setEngine'\nBlockCacheProvider.prototype.setEngine = function(engine) {\n  const self = this\n  self.engine = engine\n  // unblock initialization after first block\n  engine.once('block', function(block) {\n    self.currentBlock = block\n    self._ready.go()\n    // from now on, empty old cache every block\n    engine.on('block', clearOldCache)\n  })\n\n  function clearOldCache(newBlock) {\n    var previousBlock = self.currentBlock\n    self.currentBlock = newBlock\n    if (!previousBlock) return\n    self.strategies.block.cacheRollOff(previousBlock)\n    self.strategies.fork.cacheRollOff(previousBlock)\n  }\n}\n\nBlockCacheProvider.prototype.handleRequest = function(payload, next, end){\n  const self = this\n\n  // skip cache if told to do so\n  if (payload.skipCache) {\n    // console.log('CACHE SKIP - skip cache if told to do so')\n    return next()\n  }\n\n  // Ignore block polling requests.\n  if (payload.method === 'eth_getBlockByNumber' && payload.params[0] === 'latest') {\n    // console.log('CACHE SKIP - Ignore block polling requests.')\n    return next()\n  }\n\n  // wait for first block\n  self._ready.await(function(){\n    // actually handle the request\n    self._handleRequest(payload, next, end)\n  })\n}\n\nBlockCacheProvider.prototype._handleRequest = function(payload, next, end){\n  const self = this\n\n  var type = cacheUtils.cacheTypeForPayload(payload)\n  var strategy = this.strategies[type]\n\n  // If there's no strategy in place, pass it down the chain.\n  if (!strategy) {\n    return next()\n  }\n\n  // If the strategy can't cache this request, ignore it.\n  if (!strategy.canCache(payload)) {\n    return next()\n  }\n\n  var blockTag = cacheUtils.blockTagForPayload(payload)\n  if (!blockTag) blockTag = 'latest'\n  var requestedBlockNumber\n\n  if (blockTag === 'earliest') {\n    requestedBlockNumber = '0x00'\n  } else if (blockTag === 'latest') {\n    requestedBlockNumber = ethUtil.bufferToHex(self.currentBlock.number)\n  } else {\n    // We have a hex number\n    requestedBlockNumber = blockTag\n  }\n\n  //console.log('REQUEST at block 0x' + requestedBlockNumber.toString('hex'))\n\n  // end on a hit, continue on a miss\n  strategy.hitCheck(payload, requestedBlockNumber, end, function() {\n    // miss fallthrough to provider chain, caching the result on the way back up.\n    next(function(err, result, cb) {\n      // err is already handled by engine\n      if (err) return cb()\n      strategy.cacheResult(payload, result, requestedBlockNumber, cb)\n    })\n  })\n}\n\n//\n// Cache Strategies\n//\n\nfunction PermaCacheStrategy() {\n  var self = this\n  self.cache = {}\n  // clear cache every ten minutes\n  var timeout = setInterval(function(){\n    self.cache = {}\n  }, 10 * 60 * 1e3)\n  // do not require the Node.js event loop to remain active\n  if (timeout.unref) timeout.unref()\n}\n\nPermaCacheStrategy.prototype.hitCheck = function(payload, requestedBlockNumber, hit, miss) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n  var cached = this.cache[identifier]\n\n  if (!cached) return miss()\n\n  // If the block number we're requesting at is greater than or\n  // equal to the block where we cached a previous response,\n  // the cache is valid. If it's from earlier than the cache,\n  // send it back down to the client (where it will be recached.)\n  var cacheIsEarlyEnough = compareHex(requestedBlockNumber, cached.blockNumber) >= 0\n  if (cacheIsEarlyEnough) {\n    var clonedValue = clone(cached.result)\n    return hit(null, clonedValue)\n  } else {\n    return miss()\n  }\n}\n\nPermaCacheStrategy.prototype.cacheResult = function(payload, result, requestedBlockNumber, callback) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n\n  if (result) {\n    var clonedValue = clone(result)\n    this.cache[identifier] = {\n      blockNumber: requestedBlockNumber,\n      result: clonedValue,\n    }\n  }\n\n  callback()\n}\n\nPermaCacheStrategy.prototype.canCache = function(payload) {\n  return cacheUtils.canCache(payload)\n}\n\n//\n// ConditionalPermaCacheStrategy\n//\n\nfunction ConditionalPermaCacheStrategy(conditionals) {\n  this.strategy = new PermaCacheStrategy()\n  this.conditionals = conditionals\n}\n\nConditionalPermaCacheStrategy.prototype.hitCheck = function(payload, requestedBlockNumber, hit, miss) {\n  return this.strategy.hitCheck(payload, requestedBlockNumber, hit, miss)\n}\n\nConditionalPermaCacheStrategy.prototype.cacheResult = function(payload, result, requestedBlockNumber, callback) {\n  var conditional = this.conditionals[payload.method]\n\n  if (conditional) {\n    if (conditional(result)) {\n      this.strategy.cacheResult(payload, result, requestedBlockNumber, callback)\n    } else {\n      callback()\n    }\n  } else {\n    // Cache all requests that don't have a conditional\n    this.strategy.cacheResult(payload, result, requestedBlockNumber, callback)\n  }\n}\n\nConditionalPermaCacheStrategy.prototype.canCache = function(payload) {\n  return this.strategy.canCache(payload)\n}\n\n//\n// BlockCacheStrategy\n//\n\nfunction BlockCacheStrategy() {\n  this.cache = {}\n}\n\nBlockCacheStrategy.prototype.getBlockCacheForPayload = function(payload, blockNumberHex) {\n  const blockNumber = Number.parseInt(blockNumberHex, 16)\n  let blockCache = this.cache[blockNumber]\n  // create new cache if necesary\n  if (!blockCache) {\n    const newCache = {}\n    this.cache[blockNumber] = newCache\n    blockCache = newCache\n  }\n  return blockCache\n}\n\nBlockCacheStrategy.prototype.hitCheck = function(payload, requestedBlockNumber, hit, miss) {\n  var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n\n  if (!blockCache) {\n    return miss()\n  }\n\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n  var cached = blockCache[identifier]\n\n  if (cached) {\n    return hit(null, cached)\n  } else {\n    return miss()\n  }\n}\n\nBlockCacheStrategy.prototype.cacheResult = function(payload, result, requestedBlockNumber, callback) {\n  if (result) {\n    var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n    blockCache[identifier] = result\n  }\n  callback()\n}\n\nBlockCacheStrategy.prototype.canCache = function(payload) {\n  if (!cacheUtils.canCache(payload)) {\n    return false\n  }\n\n  var blockTag = cacheUtils.blockTagForPayload(payload)\n\n  return (blockTag !== 'pending')\n}\n\n// naively removes older block caches\nBlockCacheStrategy.prototype.cacheRollOff = function(previousBlock){\n  const self = this\n  const previousHex = ethUtil.bufferToHex(previousBlock.number)\n  const oldBlockNumber = Number.parseInt(previousHex, 16)\n  // clear old caches\n  Object.keys(self.cache)\n    .map(Number)\n    .filter(num => num <= oldBlockNumber)\n    .forEach(num => delete self.cache[num])\n}\n\n\n// util\n\nfunction compareHex(hexA, hexB){\n  var numA = parseInt(hexA, 16)\n  var numB = parseInt(hexB, 16)\n  return numA === numB ? 0 : (numA > numB ? 1 : -1 )\n}\n\nfunction hexToBN(hex){\n  return new BN(ethUtil.toBuffer(hex))\n}\n\nfunction containsBlockhash(result) {\n  if (!result) return false\n  if (!result.blockHash) return false\n  const hasNonZeroHash = hexToBN(result.blockHash).gt(new BN(0))\n  return hasNonZeroHash\n}\n","var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","const createPayload = require('../util/create-payload.js')\n\nmodule.exports = SubProvider\n\n// this is the base class for a subprovider -- mostly helpers\n\n\nfunction SubProvider() {\n\n}\n\nSubProvider.prototype.setEngine = function(engine) {\n  const self = this\n  self.engine = engine\n  engine.on('block', function(block) {\n    self.currentBlock = block\n  })\n}\n\nSubProvider.prototype.handleRequest = function(payload, next, end) {\n  throw new Error('Subproviders should override `handleRequest`.')\n}\n\nSubProvider.prototype.emitPayload = function(payload, cb){\n  const self = this\n  self.engine.sendAsync(createPayload(payload), cb)\n}"],"sourceRoot":""}